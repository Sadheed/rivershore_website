---
import { Image } from "astro:assets";

interface Slide {
  src: ImageMetadata;
  tagline: string;
  title: string[];
  desc: string;
}

interface Props {
  slides: Slide[];
}

const { slides } = Astro.props;
---

<section class="relative h-[50vh] min-h-[520px] bg-brand-navy overflow-hidden flex items-center pt-38">
  <div class="absolute inset-0 z-0">
    {slides.map((slide, index) => (
      <div 
        class={`hero-slide absolute inset-0 transition-all duration-1000 ease-in-out ${index === 0 ? 'opacity-40 scale-100' : 'opacity-0 scale-110'}`}
        data-index={index}
      >
        <Image src={slide.src} loading={"eager"} alt={slide.title[0]} class="w-full h-full object-cover grayscale" />
        <div class="absolute inset-0 bg-gradient-to-r from-brand-navy via-brand-navy/80 to-transparent"></div>
      </div>
    ))}
  </div>

  <div class="relative z-10 max-w-7xl mx-auto px-6 w-full">
    <div class="max-w-3xl">
      {slides.map((slide, index) => (
        <div class={`slide-text ${index === 0 ? 'block' : 'hidden'}`} data-index={index}>
          <p class="text-brand-green uppercase tracking-[0.4em] text-xs font-bold mb-6 animate-fade-in-up ">
            {slide.tagline}
          </p>
          <h1 class="text-4xl mb-2 md:text-6xl font-black text-white/90 mb-8 tracking-tighter uppercase leading-[0.9]">
            {slide.title[0]}<br />
            <span class="text-white/80 font-light italic ">{slide.title[1]}</span>
          </h1>
          <p class="text-slate-200 text-lg md:text-xl leading-relaxed mb-2 max-w-xl">
            {slide.desc}
          </p>
        </div>
      ))}

      <div class="mt-10 flex flex-col sm:flex-row items-start sm:items-center gap-8">
        <div class="flex gap-3 order-2 sm:order-1">
          {slides.map((_, i) => (
            <div class="h-1.5 w-12 sm:w-16 bg-white/10 rounded-full overflow-hidden mb-4">
              <div class="progress-bar h-full bg-brand-green w-0" data-index={i}></div>
            </div>
          ))}
        </div>

        <div class="flex gap-2 order-1 mb-4 sm:order-2 ">
          <button id="prevSlide" class="group border border-white/50 hover:bg-slate-600 p-4 sm:p-3 rounded-xl transition-all active:scale-95">
            <svg class="w-6 h-6 text-white group-hover:text-brand-green" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          </button>
          <button id="nextSlide" class="group border border-white/50 hover:bg-slate-600 p-4 sm:p-3 rounded-xl transition-all active:scale-95">
            <svg class="w-6 h-6 text-white group-hover:text-brand-green" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
          </button>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  @keyframes fade-in-up { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
  .animate-fade-in-up { animation: fade-in-up 0.8s forwards; }
  @media (max-width: 640px) { .slide-text h1 { font-size: 2.8rem; } }
</style>

<script>
  // 1. Define the timer type (number for browser, or ReturnType for compatibility)
  let timer: ReturnType<typeof setInterval>;
  let currentIndex: number = 0;

  // 2. Use Type Casting (as NodeListOf<HTMLElement>) to access .style and .dataset
  const slides = document.querySelectorAll('.hero-slide') as NodeListOf<HTMLElement>;
  const texts = document.querySelectorAll('.slide-text') as NodeListOf<HTMLElement>;
  const bars = document.querySelectorAll('.progress-bar') as NodeListOf<HTMLElement>;
  const total: number = slides.length;

  function updateSlider(index: number): void {
    // Clear existing timer safely
    if (timer) clearInterval(timer);

    // Update Images & Text
    slides.forEach((s, i) => {
      s.classList.toggle('opacity-40', i === index);
      s.classList.toggle('scale-100', i === index);
      s.classList.toggle('opacity-0', i !== index);
      s.classList.toggle('scale-110', i !== index);
    });

    texts.forEach((t, i) => {
      t.style.display = i === index ? 'block' : 'none';
    });

    // Update Progress Bars (Accessing .style requires the HTMLElement cast above)
    bars.forEach((b, i) => {
      b.style.transition = 'none';
      b.style.width = i === index ? '0%' : (i < index ? '100%' : '0%');
      
      if(i === index) {
        // Small timeout to allow the 'width 0%' to register before animating
        setTimeout(() => {
          b.style.transition = 'width 3000ms linear';
          b.style.width = '100%';
        }, 50);
      }
    });

    currentIndex = index;
    
    // Restart timer
    timer = setInterval(() => {
      let nextIdx = (currentIndex + 1) % total;
      updateSlider(nextIdx);
    }, 3000);
  }

  // 3. Optional Chaining (?.) for Event Listeners to avoid "Object is possibly null"
  document.getElementById('nextSlide')?.addEventListener('click', () => {
    updateSlider((currentIndex + 1) % total);
  });

  document.getElementById('prevSlide')?.addEventListener('click', () => {
    updateSlider((currentIndex - 1 + total) % total);
  });

  // Initialize first slide
  if (total > 0) updateSlider(0);
</script>